# Monads

## What is a Monad?

A monad is a design pattern in functional programming that provides a way to structure computations that involve sequential operations, especially when dealing with side effects, nullability, or other contextual computations. At its core, a monad is a type that wraps a value and provides operations to chain computations together.

## Is a Monad an Object or a Method?

**A monad is neither an object nor a method** - it's better to think of it as:

1. **A Type/Class** - In object-oriented terms, a monad is a type (like a class) that wraps a value. For example:
   - `Maybe` is a monad type
   - `Maybe.of(5)` creates an **instance** of the Maybe monad (an object)
   - `bind()` is a **method** on that monad instance

2. **A Pattern/Interface** - A monad is a pattern that defines what operations a type must support:
   - The type must have a way to wrap values (`return`/`of`)
   - The type must have a way to chain operations (`bind`/`>>=`)

3. **Think of it like this:**
   ```javascript
   // Maybe is the MONAD TYPE (like a class)
   class Maybe { ... }
   
   // Maybe.of(5) creates a MONAD INSTANCE (an object)
   const maybeFive = Maybe.of(5);  // This is an object
   
   // .bind() is a METHOD on the monad instance
   maybeFive.bind(x => Maybe.of(x * 2));  // bind is a method
   ```

**In simple terms:**
- **Monad** = The pattern/type (like "List" or "Maybe")
- **Monad instance** = An object that follows the monad pattern (like `Maybe.of(5)`)
- **bind/return** = Methods that monad instances must have

## Core Concepts

A monad must have two operations:
1. **Return/Unit** - Wraps a value into the monad
2. **Bind (>>=)** - Chains operations together, taking a value from one monad and applying a function that returns another monad

## The Monad Laws

For a type to be a proper monad, it must satisfy three laws:

1. **Left Identity**: `return a >>= f` ≡ `f a`
2. **Right Identity**: `m >>= return` ≡ `m`
3. **Associativity**: `(m >>= f) >>= g` ≡ `m >>= (\x -> f x >>= g)`

## Common Monad Examples

### 1. Maybe Monad (Optional)

The Maybe monad handles computations that might fail or return nothing.

**Haskell Example:**
```haskell
-- Maybe type definition
data Maybe a = Nothing | Just a

-- Example: Safe division
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

-- Chaining operations
result = Just 10 >>= (\x -> safeDivide x 2) >>= (\y -> safeDivide y 5)
-- Result: Just 1.0

result2 = Just 10 >>= (\x -> safeDivide x 0) >>= (\y -> safeDivide y 5)
-- Result: Nothing (stops at first failure)
```

**JavaScript Example:**
```javascript
// Maybe monad implementation
class Maybe {
  constructor(value) {
    this.value = value;
  }
  
  static of(value) {
    return new Maybe(value);
  }
  
  static nothing() {
    return new Maybe(null);
  }
  
  bind(fn) {
    return this.value === null || this.value === undefined
      ? Maybe.nothing()
      : fn(this.value);
  }
  
  map(fn) {
    return this.bind(x => Maybe.of(fn(x)));
  }
}

// Usage
const safeDivide = (x, y) => y === 0 ? Maybe.nothing() : Maybe.of(x / y);

const result = Maybe.of(10)
  .bind(x => safeDivide(x, 2))
  .bind(y => safeDivide(y, 5));
// result.value = 1.0

const result2 = Maybe.of(10)
  .bind(x => safeDivide(x, 0))
  .bind(y => safeDivide(y, 5));
// result2.value = null
```

### 2. List Monad

The List monad represents non-deterministic computations (multiple possible results).

**Haskell Example:**
```haskell
-- List comprehension using monads
pairs = [1, 2, 3] >>= \x -> [4, 5, 6] >>= \y -> return (x, y)
-- Result: [(1,4), (1,5), (1,6), (2,4), (2,5), (2,6), (3,4), (3,5), (3,6)]

-- Equivalent to:
pairs = do
  x <- [1, 2, 3]
  y <- [4, 5, 6]
  return (x, y)
```

**JavaScript Example:**
```javascript
// List monad implementation
class List {
  constructor(values) {
    this.values = values;
  }
  
  static of(value) {
    return new List([value]);
  }
  
  bind(fn) {
    return new List(
      this.values.flatMap(x => fn(x).values)
    );
  }
  
  map(fn) {
    return new List(this.values.map(fn));
  }
}

// Usage
const pairs = new List([1, 2, 3])
  .bind(x => new List([4, 5, 6])
    .bind(y => List.of([x, y])));
// pairs.values = [[1,4], [1,5], [1,6], [2,4], [2,5], [2,6], [3,4], [3,5], [3,6]]
```

### 3. IO Monad

The IO monad handles side effects in a pure functional way.

**Haskell Example:**
```haskell
-- IO monad for handling input/output
main = do
  putStrLn "What's your name?"
  name <- getLine
  putStrLn ("Hello, " ++ name ++ "!")
```

**JavaScript Example:**
```javascript
// IO monad implementation
class IO {
  constructor(effect) {
    this.effect = effect;
  }
  
  static of(value) {
    return new IO(() => value);
  }
  
  bind(fn) {
    return new IO(() => fn(this.effect()).effect());
  }
  
  run() {
    return this.effect();
  }
}

// Usage
const getLine = new IO(() => prompt("What's your name?"));
const putStrLn = (str) => new IO(() => console.log(str));

const program = getLine.bind(name => 
  putStrLn(`Hello, ${name}!`)
);

program.run(); // Executes the IO operations
```

### 4. Either Monad (Result)

The Either monad represents computations that can result in either success or failure.

**Haskell Example:**
```haskell
data Either a b = Left a | Right b

-- Example: Parsing a number
parseInt :: String -> Either String Int
parseInt s = case reads s of
  [(n, "")] -> Right n
  _         -> Left ("Could not parse: " ++ s)

-- Chaining operations
result = parseInt "10" >>= (\x -> parseInt "5" >>= (\y -> Right (x + y)))
-- Result: Right 15

result2 = parseInt "abc" >>= (\x -> parseInt "5" >>= (\y -> Right (x + y)))
-- Result: Left "Could not parse: abc"
```

**JavaScript Example:**
```javascript
// Either monad implementation
class Either {
  constructor(value, isLeft) {
    this.value = value;
    this.isLeft = isLeft;
  }
  
  static left(value) {
    return new Either(value, true);
  }
  
  static right(value) {
    return new Either(value, false);
  }
  
  bind(fn) {
    return this.isLeft ? this : fn(this.value);
  }
  
  map(fn) {
    return this.isLeft ? this : Either.right(fn(this.value));
  }
}

// Usage
const parseInt = (str) => {
  const num = Number(str);
  return isNaN(num) 
    ? Either.left(`Could not parse: ${str}`)
    : Either.right(num);
};

const result = parseInt("10")
  .bind(x => parseInt("5")
    .bind(y => Either.right(x + y)));
// result.value = 15, result.isLeft = false

const result2 = parseInt("abc")
  .bind(x => parseInt("5")
    .bind(y => Either.right(x + y)));
// result2.value = "Could not parse: abc", result2.isLeft = true
```

## Why Use Monads?

1. **Composability**: Monads allow you to chain operations in a clean, readable way
2. **Error Handling**: They provide a structured way to handle failures (Maybe, Either)
3. **Separation of Concerns**: They separate pure computations from side effects (IO)
4. **Abstraction**: They provide a common interface for different types of computations

## Real-World Applications

- **Promise/Async**: JavaScript Promises are similar to monads, allowing you to chain asynchronous operations
- **Optional Types**: Languages like Swift, Kotlin, and Rust have built-in optional types that follow monadic patterns
- **Functional Libraries**: Libraries like Ramda, Lodash-fp, and fp-ts provide monadic utilities

## Key Takeaways

- Monads wrap values and provide a way to chain computations
- They must satisfy three laws (left identity, right identity, associativity)
- Common monads include Maybe, List, IO, and Either
- They help manage side effects, errors, and complex computations in a functional way
- Understanding monads helps write more composable and maintainable code

